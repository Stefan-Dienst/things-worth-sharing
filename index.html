<!DOCTYPE html>
<html lang="en">

<head>
    <title>Things worth sharing</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://thingsworthsharing.dev/style.css">
    <link rel="stylesheet" href="https://thingsworthsharing.dev/color/orange.css">

        <link rel="stylesheet" href="https://thingsworthsharing.dev/color/background_dark.css">
    
    <link rel="stylesheet" href="https://thingsworthsharing.dev/font-hack-subset.css">

    <meta name="description" content="My blog.">

    <meta property="og:description" content="My blog.">
    <meta property="og:title" content="Things worth sharing">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://thingsworthsharing.dev/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="My blog.">
    <meta name="twitter:title" content="Things worth sharing">
    <meta property="twitter:domain" content="thingsworthsharing.dev">
    <meta property="twitter:url" content="https://thingsworthsharing.dev/">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://thingsworthsharing.dev" style="text-decoration: none;">
                    <div class="logo">
                      
                            Things worth sharing
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://thingsworthsharing.dev">blog</a></li>
            
                <li><a href="https://thingsworthsharing.dev/pages/archive">archive</a></li>
            
                <li><a href="https://thingsworthsharing.dev/pages/about">about me</a></li>
            
                <li><a href="https://github.com/Stefan-Dienst" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://thingsworthsharing.dev/things-i-learned-about-learning/">Things I learned about learning</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-01-19
        </span>

    </div>

    


                    <div class="post-content">
            <p>Learning has always been an ambivalent topic for me.
In school, it was cumbersome, and I didn’t find much joy in it.
On the other hand, I’ve always enjoyed picking up new skills that interest me, like juggling or card magic.
While I’ve never deeply developed any particular skill, I’ve become better at learning autonomously.</p>
<p>This autonomy helped me later in life, especially when I did a career switch from physics to software/data engineering three years ago.
While I was skilled enough to land a job, I lacked knowledge in several areas and felt behind with a lot of ground to cover.
My old, intuitive way of learning had worked before, but it felt inefficient and unsatisfactory.
I didn't feel in control of the things I learned, and I reacted more to the things I randomly encountered rather than following a structure.
Also, nothing really seemed to stick for long.
I often had to <em>relearn</em> things, which felt more like starting from scratch rather than building on the past.</p>
<p>As I believe that learning is one of the most important skills in life, especially in areas that change quickly like software engineering, I decided to try to get better at it.
I have read, viewed and studied some resources and tried various approaches and refined the ones that worked best for me.
In the following, I present some of my key findings that I believe have been the most important in improving my way of learning.
Note that all of this is non-scientific, highly opinionated and just a snapshot of my current thinking.</p>
<h2 id="you-will-forget-things-get-used-to-it">You will forget things, get used to it</h2>
<p>Our brain is not meant for endless storing and exact retrieval of knowledge[^1].
Accept this.
We will all forget things we previously spent a lot of time to learn and understand.</p>
<p>For me this always felt disappointing, like losing something valuable, so why even acquire it?
Also learning something new always has this feeling that I would need to forget something old.
The key to solving this dilemma for me was to first change my view on learning.
Instead of seeing the goal of learning in being able to remember facts, I shifted to enjoying the process of changing the way I think.
So even though I know that I will not be able to remember all of it in the future, I know that new connections have formed in my brain that may make it easier for me to pick up something similar.</p>
<p>Second I implemented a knowledge management system, where I write atomic notes on the things I learn.
These atomic notes are like short summaries of concepts or fractions of concepts that are small enough to view and quickly grasp in isolation, even though they may be part of something far bigger.
They act like checkpoints in a video game and allow me to pause studying a topic and come back to it later.
So even when I will forget things it does not feel like I lost something, as I can easily retrieve it by reading my own thoughts.
After all, who could better teach you a topic than yourself?
This allows me to forget and lowers the pressure of keeping everything in my brain.</p>
<p>In a sense I have used such knowledge management systems, or like some call it second brains, unconsciously in the past.
Like remembering only where in a book or website specific things are written instead of remembering them myself.
So building and using such a system consciously for learning and separating it from external resources just made sense.</p>
<p>Another great thing about writing about the things you learn is that you are actually forced to actively engage with the topics you are studying.
You stop from being a passive consumer and already become a creator just by recapitulating things in your own words or consolidating multiple sources.
This idea is so important that it will pop up multiple times throughout this blog.</p>
<p>To build your own knowledge management system, I would recommend starting as small as possible and getting things going.
There are endless tools and frameworks out there with varying complexity, just choose something that looks fine; you will not get it perfect the first time you try anyway.
Stick with it and refine it as you go.
You will notice things that work for you and things that bring you no value.
Feel free to drop things that bring you no value, and don't get fixated on doing it the 'right' way.
Building a knowledge management system is very personal, so your way will quickly diverge from postulated systems from experts.</p>
<p>The only thing I would say that is a must have for such a system is that you can trust it.
As you will put a lot of time and value in it, the things you write should be secure.
I would recommend first implementing a backup strategy for your system that you can trust.
Then you can fully engage with it without a worry.
(But other people have far higher requirements for the system they use <a href="https://fortelabs.com/blog/how-to-choose-your-second-brain-app/">see this blog post</a>.</p>
<p>For my system I mainly use <a href="https://de.m.wikipedia.org/wiki/Markdown">markdown</a> files that I edit with <a href="https://neovim.io/">neovim</a>.
I sync those files with my phone using <a href="https://syncthing.net/">Syncthing</a>, as it is very important to me to also have access to my notes when I am not at home.
On my phone I use the <a href="https://obsidian.md/">Obsidian</a> app, which in the end is just a nice (but extremely powerful) wrapper around markdown files.
For example it allows to reference other notes, creating connections between, which can be very helpful to navigate older notes and put things in perspective.
As I am using Obsidian I also use <a href="https://github.com/epwalsh/obsidian.nvim">this vim plugin</a>.
To trust my system and make it durable I make daily automated backups to an external harddrive and my Google drive using <a href="https://rclone.org/">rclone</a>.
With this, I have relatively recent versions of my notes on four devices at all times.</p>
<p>Here is a graph view in the Obsidian app of some of my notes and how they connect with each other:

  
  
    
    
  
  <img src="https://thingsworthsharing.dev/images/graph-view-obsidian.png" class="center" style="border-radius: 0px; float: center; padding: 10px; margin: 10px 0 10px 20px;width: 450px" decoding="async" loading="lazy"/>

</p>
<h2 id="learning-is-effort-and-is-not-supposed-to-be-easy">Learning is effort and is not supposed to be easy</h2>
<p>Learning differs significantly from merely being presented with knowledge.
Learning is exhausting and often not pleasant.
It involves being challenged and getting frustrated.
If something is too pleasant, you should question whether your are actually learning or just consuming.</p>
<p>When I noticed this the first time I felt discouraged, because my natural instinct is to avoid uncomfortable situations.
Feeling frustrated when learning something new made me think that I was doing something wrong and I rather questioned if I was on the right track.
Perhaps I was indeed doing something wrong by challenging myself too hard and should have chosen a different approach.
On the other hand, simply doing things that come easily to oneself will not lead to actual growth.
What remains is a small sweet spot area where you feel slightly uncomfortable and may sometimes get frustrated, but you are not too far away from your area of competency to easily get discouraged.
Finding this area is not easy but being sure that it exists, no matter where you are coming from, helps.</p>
<p>For me one example of this was when I was working through the book "The Algorithm Design Manual" by Steven S. Skiena and tried my luck on the suggested leet code challenge as an exercise in one of the early chapters.
I quickly got stuck on a challenge that required a <a href="https://medium.com/carpanese/a-visual-introduction-to-fenwick-tree-89b82cac5b3ca">Fenwick tree</a>, a rather advanced data structure, that was just too hard to grasp at my current level of understanding.
Even though I pushed through with the help of external resources, it took me an enormous amount of time and I thought about just not doing these challenges anymore for the following chapters.</p>
<p>But instead I just acknowledged that some of the suggested challenges were too hard for me at the time and took a step back.
I sought out related easier challenges first before tackling the suggested ones.
And started to systematically work through learning paths of easier concept like <a href="https://leetcode.com/studyplan/leetcode-75/">LeetCode 75 </a>, to gradually train my problem solving.
While this made my progress feel slower as I had to work through more stuff, it made it far more enjoyable and helped me build up momentum.</p>
<p>On another note, I have become more aware of the big difference between simply consuming knowledge and actual learning by engaging with it.
It may sound like a foolish thing, but I simply asked myself:
"With deep knowledge on all niche topics available at our finger tips.
May it be through classic books, YouTube tutorials or generated by some large language model.
What stops anyone from becoming an expert by just consuming the essentials as fast as possible?"
It just felt like a straightforward path that anyone with enough time on their hands could achieve.</p>
<p>But personally I noticed that just consuming excellent work, does not lead to excellent understanding.
With recommendation algorithms suggesting all kind of content, I have consumed videos that delve into in-depth art analyses, historical events or workings of the economy.
And while these videos were well structured and covered topics exhaustively I don't feel knowledgeable about any of these topics.
I may have come across a new idea or concept that felt new and exciting while watching, but actually retrieving this information to explain it to someone else or putting it in context with other things, felt impossible.
The only things that stuck with me are out of context fun facts. (Which is still neat.)</p>
<p>The key difference between consuming knowledge and truly learning is the act of actively engaging with new information.
Even if a concept is presented to you in organized and bite-sized portions, you must make the effort to "re-invent" it yourself.</p>
<ul>
<li>You have to care about the problem it solves, because, after all, why should you understand it if it brings you no value.</li>
<li>You have to understand how it relates to the bigger picture. Concepts do not exist in a vacuum, they are always connected. Finding these connections makes them easier to remember and accelerates learning new ones as you can leverage your existing understanding.</li>
<li>You have to challenge your understanding of it. Explain it to yourself or others without using the original source. Look for weak points. Maybe you find out your understanding was incorrect and needs adjustment.</li>
<li>You need to use it. Actually using new knowledge can feel so rewarding. Additionally, by using it you will be forced to go through the above steps.</li>
</ul>
<p>I first encountered these ideas in an excellent <a href="https://youtu.be/Dm68uFy6gus?si=toKo8s2GoAUpJszz">YouTube video</a>, which I highly recommen—and ultimately summarized parts of it to deepen my understanding.</p>
<p>To enforce parts of this in my learning routine I use a popular system, which brings me to my next topic.</p>
<h2 id="use-spaced-repetition-with-effortful-retrieval">Use spaced repetition with effortful retrieval</h2>
<p>Spaced repetition is the process of repeating learning exercises in intervals that adjust based on your performance.
In practice this means that you repeat a learning exercises more often when it is new to you and the better you get at it the less frequent you repeat it.
The goal here is to repeat an exercise when you begin to forget about it, refreshing the connections in your brain.
You may be familiar with this approach for learning vocabulary and there exist many tools to easily implement it.
I use <a href="https://www.stephenmwangi.com/obsidian-spaced-repetition/">Obsidian Spaced Repetition</a>.</p>
<p>Spaced repetition works great in combination with my personal knowledge management system.
Here I treat the effortful retrieval of a note as a learning exercise.
In practice this means that I try to recapitulate the gist of a note to myself, figuring out how I would explain the concept to someone unfamiliar with it.
This forces me to actively engage with the knowledge, always re-inventing it as described in the previous section.</p>
<p>In action this looks like this:</p>
<div style="display: flex; align-items: center; margin-bottom: 40px;">
  <p style="flex: 1; margin-right: 20px;">
    Each note I want to review using spaced repetition is assigned a due date for its next review.
  </p>
  
  
  
    
    
  
  <img src="https://thingsworthsharing.dev/images/spaced-repetition-1.png" class="center" style="border-radius: 0px; width: 300px;" decoding="async" loading="lazy"/>


</div>
<div style="display: flex; align-items: center; margin-bottom: 20px;">
  <p style="flex: 1; margin-right: 20px;">
    For every day I then have a list of notes to review.
  </p>
  
  
  
    
    
  
  <img src="https://thingsworthsharing.dev/images/spaced-repetition-2.png" class="center" style="border-radius: 0px; width: 250px;" decoding="async" loading="lazy"/>


</div>
<div style="display: flex; align-items: center;">
  <p style="flex: 1; margin-right: 20px;">
    Depending on "how good I did" I rank the notes as either easy, good or hard, which sets the next due date to either later or earlier.
  </p>
  
  
  
    
    
  
  <img src="https://thingsworthsharing.dev/images/spaced-repetition-3.png" class="center" style="border-radius: 0px; width: 300px;" decoding="async" loading="lazy"/>


</div>
<p>Doing multiple repetitions of anything I learned sounded daunting at first and I must admit that it still is tedious sometimes.
Additionally, it is tempting to start a new topic as soon as the previous one is completed, as it feels more rewarding.
But I have found that spaced repetition is by far the most effective tool for persistent and sustainable knowledge increase.</p>
<p>First you actually remember what you just studied.
I notice a great discrepancy in recall of things I just consumed and those I actively engaged with by doing a few rounds of spaced repetition.
I often experience this when I discover a note I have no memory of, realizing I forgot to put in the spaced repetition loop.</p>
<p>But the most important aspect I see in spaced repetition is that everything, no matter if you remember it in your sleep, comes back at you.
This way you can think about them with a new perspective maybe understanding them on a deeper level.
Moving from a more abstract idea to a concrete example and back, see <a href="https://cacm.acm.org/research/10-things-software-developers-should-learn-about-learning/#sec5">semantic wave</a>.
Or taking advantage of the things you have learned in-between to find new connection or detecting errors in your old reasoning.
Additionally, it helps to tackle hard things.
Quite often I write a note about a concept I do not fully grasp at the time.
I no longer feel bad about this, but just drop perfectionism and add it to the loop, knowing that I will figure it out down the line.</p>
<h2 id="take-on-and-seek-out-learning-opportunities">Take on and seek out learning opportunities</h2>
<p>Learning opportunities arise more often than you might think.
The things that can have the biggest potential to increase your knowledge can sometimes be right in front of you.
Take those opportunities on and seek them out.</p>
<p>The thing I find most stressful as an engineer is if something breaks, I don't know why, and I have to fix it quickly.
I dread this combination of urgency and being out my comfort zone.
Unfortunately in such situations I often find myself defaulting to inefficient problems solving techniques.
Such as extreme loops of trial and error without reasoning and just using things I found online.
I think I do this, because not fully grasping the issue at hand is uncomfortable and taking it slow to actually understand what is happening is challenging.
Taking it slow can feel like no progress is being made.
So I prefer the <em>easy way</em> of rapidly doing actions, while mostly inefficient, to the tougher challenge of actually facing and fixing my blind spots.</p>
<p>As such situations are not a rarity and arise more often than I wish, I have started to view them as learning experiences that I have to take on instead of simply <em>fixing</em>.
I try to not panic and just solve them as fast as possible, but actually take my time to understand what is happening.
This can lead to frustration and despair, but as mentioned before, while this is uncomfortable, it is often just a sign that learning is going on.
I try to use those feelings as a guide and appreciate them.
The first time I came across this idea was in Julia Evans' zine <a href="https://wizardzines.com/zines/debugging-guide/"><em>The Pocket Guide to Debugging</em></a>, which I highly encourage you to check out.</p>
<p>Unfortunately this is far easier said than done, but what I have found most useful is to reduce the feeling of urgency as best as possible.
Often, things feel far more urgent than they actually are, and being uncomfortable only enhances this.
So when I feel the itch to fall back to inefficient fast action methods I do a reality check to figure out how much time I could actually spend on an issue.
In other situations I seek out a quick and dirty solution to mitigate an issue and give myself time that I can spend in peace.</p>
<p>What I have found is that such situations, while uncomfortable, can serve as the best learning experiences and greatly enhance one's understanding.
Additionally, I have found that I do not need to wait for things to actually crash.
Often I can find such valuable experiences in the things I procrastinated on or in tasks that no one on the team wants to do.
What helps me to find and take on such challenges is to reflecting on why I don't want to do them.
Is it because they are tedious and boring, or am I actually just not confident enough to perform the required tasks?
So, in short, if it is a skill issue, do the task and learn something.</p>
<h2 id="focus-your-effort">Focus your effort</h2>
<p>In learning, like (almost) everything else in life, focusing on concrete goals and making steady progress beats aimless sprints.
You should learn with an action in mind: to apply the newfound knowledge or to follow some broader high-level goal.</p>
<p>Don't treat learning like some mindless consumption on an endlessly scrolling dopamine app.
Don't hop from topic to topic without going deeper than surface level.
I have often fallen to this trap and still do.
While it is enjoyable for the sake of curiosity and broadens one's perspective, in the end, nothing really <em>sticks</em>, and the result feels hollow to me.
To combat this, I use two approaches.</p>
<p>The first is that I follow one or more foundational, long-term goals, for example, <a href="https://teachyourselfcs.com/">teaching myself computer science</a>.
While I often cannot directly apply anything I learn here, the knowledge foundation I build helps me pick up things faster when I actually need them.
It acts as a long-term investment where I am sure it will not quickly fall out of fashion, in contrast to some hyped flavor of the month.</p>
<p>The second approach is that I try to learn similarly to the <a href="https://en.m.wikipedia.org/wiki/The_Toyota_Way">Toyota way</a>.
Toyota only builds car parts when they are needed, so I try to only dig deeper into a topic when I want to actually apply it in the near future.
While it can be tempting to experiment with a shiny new framework by skimming through documentation and completing tutorials.
I have often found little value in it if I don't use it to solve real problems and gain practical experience with it.
Therefore, I try to avoid getting sidetracked and focus on improving at the things I am actually using.
For a deeper insight on this aspect see this <a href="https://www.nateliason.com/blog/infomania">great blog post</a>.</p>
<p>This combination of building long-term fundamental knowledge and spiking in detailed areas that I encounter every day, has served me well.
While it is still hard not to fall victim to <a href="https://en.m.wikipedia.org/wiki/Fear_of_missing_out">FOMO</a>, it feels great when I notice that I can pick up a new framework more quickly by leveraging knowledge of some underlying concept.
Additionally, focusing on a few areas to gain an understanding beyond the advanced level not only tremendously helps with everyday work, but can also yield unexpected transferable skills.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>Reflecting on the things I have written, I come to the conclusion that I now learn more systematically and consciously.
I use systems to make hard challenges easier, and therefore feel more confident and secure tackling them.
Also, due to repetition and reflection, I have become more aware of how I am thinking while learning.
(a process I recently learned is called <a href="https://en.m.wikipedia.org/wiki/Metacognition">metacognition</a>).
This allows me to learn more efficiently and make it more enjoyable, so I continue to do it.
Overall, I am quite happy with the progress I have made and hope that reading my experiences helps you reflect on the way you learn.</p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://thingsworthsharing.dev/gpu-passthrough/">How to do a GPU passthrough on Beelink SER 5 - Ryzen 7 5800H with Proxmox on Ubuntu VM</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-11-22
        </span>

    </div>

    


                    <div class="post-content">
            <p>After I installed Proxmox on my <a href="https://www.bee-link.com/en-de/products/beelink-ser5-max-5800h">Beelink SER 5 - Ryzen 7 5800H</a> I wanted to start an Ubuntu VM with GPU passthrough that I could use as a daily driver.
As I had zero prior experience with doing something like this my process was full of following guides I barely understood, frustrating trial and error and reading about the things I just tried to do.
This journal describes this process.
It should not be seen as a complete guide, as I am far too inexperienced to verify if I did everything correctly.
But maybe it helps someone like me who is lost and googling error messages.</p>
<p>Before describing my journey I want to point out a few guides, with which I would not have been able to get it done:</p>
<ul>
<li><a href="https://forum.proxmox.com/threads/guide-ryzen-5800h-igpu-passthrough-hdmi-windows11-htpc.153405/">A guide that describes the process for the same machine I used but for a Windows VM</a>: This guide saved me. Before I found it I was close to giving up. So big shout outs.</li>
<li><a href="https://github.com/isc30/ryzen-7000-series-proxmox/?tab=readme-ov-file#proxmox---ryzen-7000-series---amd-radeon-680m780mrdna2rdna3-gpu-passthrough">Comprehensive guide for Ryzen 7000 series GPU passthrough</a>: The guide above used this one for many steps.</li>
<li><a href="https://nopresearcher.github.io/Proxmox-GPU-Passthrough-Ubuntu/">GPU passthrough to an Ubuntu VM, but with a NVIDIA GPU</a>: This was the first guide I started with and it got me on track. Unfortunately it did not work out of the box for me. (Probably because I also have a different GPU setup.)</li>
</ul>
<h1 id="my-journey">My journey</h1>
<p>After I ran head first into following a guide and not getting results I decided to take a step back and first gather more information on what a GPU passthrough even is.
I came up with the following description:</p>
<h2 id="gpu-passthrough">GPU Passthrough</h2>
<p>GPU Passthrough is a technique in virtualization and a form of PCI Passthrough, where the Graphics Processing Unit of the Hypervisor (for me Proxmox) host machine is directly assigned to a Virtual machine (VM).
This way the VM can access the GPU as if it is directly connected to it.</p>
<p>Normally a hypervisor provides virtual hardware to a VM and if this is done for a GPU one speaks of a virtual GPU (vGPU).
Here multiple VMs can have access to a real physical one, but this way a single VM may not be able to use the full potential of the GPU.
Additionally the hypervisor adds overhead to the communication leading to reduced performance.
Now GPU Passthrough acts as a solution to this problem, by bypassing the virtualization layer, giving the VM near native performance of the GPU.</p>
<h3 id="steps-to-enable-it">Steps to enable it</h3>
<ol>
<li><strong>Enable Input-Output Memory Management Unit (IOMMU)</strong>: IOMMU is necessary to isolate the GPU. It allows to map physical memory address to virtual ones and can therefore be used to restrict the access only to a single virtual machine.</li>
<li><strong>Blacklist the host driver</strong>: By blacklisting the host Driver of the GPU the host machine will no longer be able to access the GPU. This way the <strong>Virtual Function IO (VFIO)</strong> will be able to take control over it without any timing issues due to interference of the host machine.</li>
<li><strong>Bind the GPU to the Virtual Function IO</strong>: Here the VFIO acts as a driver that then has the control over the GPU and can give direct access to the VM. This way the host machine will no longer have access to it.</li>
<li><strong>Assign the GPU to the VM</strong>: After the GPU is bound to the VFIO one can assign it to any VM.</li>
<li><strong>Install the necessary driver on the VM</strong>: To ensure that the VM can actually use the assigned GPU the necessary driver need to be present.</li>
</ol>
<h2 id="naively-following-the-steps">Naively following the steps</h2>
<h3 id="0-define-the-vm-that-you-want-to-launch">0. Define the VM that you want to launch</h3>
<p>Here many guides exist like:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=5j0Zb6x_hOk">YouTube: Everything You Need to Know to Start with Proxmox VE</a></li>
<li><a href="https://www.youtube.com/watch?v=VAJWUZ3sTSI">YouTube: Don’t run Proxmox without these settings!</a></li>
</ul>
<p>For my case I just copied the download link from: <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a> and then downloaded the image to the local storage.
Afterwards I did some standard configuration.
The only thing out of the ordinary was that I used OVMF for the BIOS.</p>
<p>OVMF stands for Open Virtual Machine Firmware, and it is an open-source implementation of the Unified Extensible Firmware Interface (UEFI) specification.
UEFI is a modern firmware interface that replaces the traditional BIOS (Basic Input/Output System) found in older systems.
UEFI offers several advantages over BIOS, including support for larger disk sizes, faster boot times, secure boot, and improved system management capabilities.</p>
<p>What I can recommend is to install ssh on the VM so that you can still access it without a GUI.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>sudo apt update
</span><span>sudo apt install openssh-server
</span><span>sudo systemctl status ssh
</span></code></pre>
<h3 id="1-enable-input-output-memory-management-unit-iommu">1. Enable Input-Output Memory Management Unit (IOMMU)</h3>
<p>The Input-Output Memory Management Unit (IOMMU) is a hardware features of modern CPUs that allows the Operating System (OS) to control how I/O devices access the memory.
It acts as a form of gatekeeper and is therefore similar to how the Memory Management Unit handles the access of the CPU to the memory</p>
<p>To enable it I needed to configure the Grand Unified Boot Loader (GRUB) of the host machine.
In a normal boot process the GRUB is started by the BIOS and is responsible for loading the operating system.
In my case with Proxmox it loads the Linux kernel.
The way it behaves can be configured in the <code>/etc/default/grub</code> file, which can be edited with <code>sudo nano /etc/default/grub</code>.
After an update the command <code>sudo update-grub</code> must be run to reload it.</p>
<p>To enable the IMMOU I often read that one has to add <code>iommu=on</code> or in my case with an AMD CPU <code>amd_iommu=on</code>.
In my trial and error process it turned out that I did not have to enable the IOMMU this way.
Instead I only set <code>iommu=pt</code>, by changing the line <code>GRUB_CMDLINE_LINUX_DEFAULT="quite"</code> to <code>GRUB_CMDLINE_LINUX_DEFAULT="quite iommu=pt"</code>.
As far as I know this should enable the passthrough mode in the IOMMU and enhance performance.</p>
<h3 id="2-blacklist-the-host-driver">2. Blacklist the host driver</h3>
<p>This step was rather straight forward.
I just had to execute:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>echo &quot;blacklist amdgpu&quot; &gt;&gt; /etc/modprobe.d/blacklist.conf
</span><span>echo &quot;blacklist radeon&quot; &gt;&gt; /etc/modprobe.d/blacklist.conf
</span></code></pre>
<p>This puts these two drivers in the blacklist, so they won't be automatically loaded in the boot process.</p>
<p>If you wonder about the <code>modprobe</code> in the path, this stands for a Linux command that bears the same name.
The command <code>modprobe</code> allows to load or unload a kernel module, in our case a driver.
By using <code>modprobe &lt;module name&gt;</code> the specified module is loaded in the Linux kernel.
This way the system can use the hardware that is specified by the module.
By adding the flag <code>-r</code> the module is unloaded.</p>
<h3 id="3-bind-the-gpu-to-the-virtual-function-io">3. Bind the GPU to the Virtual Function IO</h3>
<p>To bind the GPU to the VFIO I first had to ensure that all necessary modules are loaded into the Linux kernel in the boot process.
To do this I executed the following command:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#96b5b4;">echo </span><span>&quot;</span><span style="color:#a3be8c;">vfio</span><span>&quot; &gt;&gt; /etc/modules
</span><span style="color:#96b5b4;">echo </span><span>&quot;</span><span style="color:#a3be8c;">vfio_iommu_type1</span><span>&quot; &gt;&gt; /etc/modules
</span><span style="color:#96b5b4;">echo </span><span>&quot;</span><span style="color:#a3be8c;">vfio_pci</span><span>&quot; &gt;&gt; /etc/modules
</span><span style="color:#96b5b4;">echo </span><span>&quot;</span><span style="color:#a3be8c;">vfio_virqfd</span><span>&quot; &gt;&gt; /etc/modules
</span></code></pre>
<p>Afterwards I needed to identify the GPU, which can be done by using <code>lspci -v</code> and looking for a "VGA compatible controller".
In my case:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>04:00.0 VGA compatible controller: Advanced Micro Devices, Inc. [AMD/ATI] Cezanne [Radeon Vega Series / Radeon Vega Mobile Series] (rev c5) (prog-if 00 [VGA controller])
</span><span>04:00.1 Audio device: Advanced Micro Devices, Inc. [AMD/ATI] Renoir Radeon High Definition Audio Controller
</span></code></pre>
<p>Here the first column is a combination of bus, device and function number.
In my case <code>04:00.0</code>:</p>
<ul>
<li><code>04</code>: Bus number.</li>
<li><code>00</code>: Device number.</li>
<li><code>0</code>: Function number.</li>
</ul>
<p>This value can then be used to access further information by executing <code>lspci -n -s 04:00</code>, which yielded in my case:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>04:00.0 0300: 1002:1638 (rev c5)
</span><span>04:00.1 0403: 1002:1637
</span><span>04:00.2 1080: 1022:15df
</span><span>04:00.3 0c03: 1022:1639
</span><span>04:00.4 0c03: 1022:1639
</span><span>04:00.5 0480: 1022:15e2 (rev 01)
</span><span>04:00.6 0403: 1022:15e3
</span></code></pre>
<p>Here the second column is the class code in hexadecimal, which provides information about the type of device.
The third column is the vendor and device id in the format <code>&lt;vendor-id&gt;:&lt;product-id&gt;</code>.
In my case <code>1022</code> stands for AMD and e.g. <code>1638</code> uniquely identifies a specific model of device from the vendor.
The last column is optional and is the Revision Id that indicates the specific version of a device.</p>
<p>For binding the GPU the important part is the <code>&lt;vendor-id&gt;:&lt;product-id&gt;</code>.
I used the top one (the GPU) and the second one (an audio device) and binded them using <code>echo "options vfio-pci ids=1002:1638, 1002:1637" &gt; /etc/modprobe.d/vfio.conf</code>.</p>
<p>After a reboot one can execute <code>lspci -v</code> and check if the Kernel driver that is used for the GPU is now <code>vfio-pci</code> instead of the previous one (in my case it was <code>amdgpu</code>).</p>
<h3 id="4-assign-the-gpu-to-the-vm">4. Assign the GPU to the VM</h3>
<p>This can be easily be done via the Proxmox GUI using VM -&gt; Hardware -&gt; Add -&gt; PCI Device.</p>
<p>But I ran into the issue that whenever I started the VM, my host machine would become unresponsive.
I could identify that this did not happen when I <strong>did not check</strong> the box "All Functions".</p>

  
  
    
    
  
  <img src="https://thingsworthsharing.dev/images/proxmox-gpu-all-functions.png" class="center" style="border-radius: 0px; float: center; padding: 10px; margin: 10px 0 10px 20px;" decoding="async" loading="lazy"/>

<h3 id="5-install-the-necessary-driver-on-the-vm">5. Install the necessary driver on the VM</h3>
<p>Since I used Ubuntu for the VM and an AMD GPU, I didn't have to install anything, as the <code>amdgpu</code> driver is readily available.</p>
<h2 id="issues-i-ran-into">Issues I ran into</h2>
<p>While the steps described above sound nice and simple I encountered multiple issues.</p>
<h3 id="missing-bios-rom">Missing BIOS ROM</h3>
<p>After naively following the steps I did not receive any output at the display linked to the host machine when I started the VM.
After ssh-ing into the VM I could check via <code>sudo lshw -c display</code> that GPU was detected, but that the driver was not is use for it.
Further debugging by using <code>sudo dmesg</code> to check the kernel ring buffer revealed the following error logs:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>amdgpu: Unable to locate a BIOS ROM
</span><span>amdgpu: Fatal error during GPU init
</span></code></pre>
<p>This should mean more or less, that the GPU could not be initialized by the VM, because it can not access the GPU firmware stored on in the read-only memory (ROM).
I encountered this error, because I skipped an important step: Making the GPU BIOS available to the VM.</p>
<p>To fix this I wanted to extract GPU BIOS, by using the tool <a href="https://github.com/stylesuxx/amdvbflash">amdvbflash</a> on the host machine, but here I had no success and only encountered the following error:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>root@proxmox:~/flash-gpu# ./amdvbflash -i
</span><span>AMDVBFLASH version 4.71, Copyright (c) 2020 Advanced Micro Devices, Inc.
</span><span>
</span><span>Adapter not found
</span></code></pre>
<p>I am unsure, but I think the reason that this tool could not detect my GPU is due to my GPU being an AMD Cezanne one.
Cezanne is a codename for a specific architecture GPUs that combine both a CPU and a GPU on the same chip.
But I am not sure about that.</p>
<p>But I was in luck and <a href="https://forum.proxmox.com/threads/guide-ryzen-5800h-igpu-passthrough-hdmi-windows11-htpc.153405/">this guide here</a> linked me to a description of the BIOS extraction process see here: <a href="https://github.com/isc30/ryzen-7000-series-proxmox/?tab=readme-ov-file#configuring-the-gpu-in-the-windows-vm">https://github.com/isc30/ryzen-7000-series-proxmox/?tab=readme-ov-file#configuring-the-gpu-in-the-windows-vm</a>.</p>
<p>Additionally I did the <a href="https://github.com/isc30/ryzen-7000-series-proxmox/?tab=readme-ov-file#optional-getting-ovmf-uefi-bios-working-error-43">following steps</a> for the audio device.
But I do not know if this was necessary.</p>
<h3 id="stuck-at-800x600-resolution">Stuck at 800x600 resolution</h3>
<p>After extracting the GPU BIOS finally got output on my display, but I could not adjust the resolution and was stuck at 800x600.
The reason for this was probably a bug called AMD GPU reset.
But I was again lucky and found another guide that described how to resolved it: <a href="https://www.nicksherlock.com/2020/11/working-around-the-amd-gpu-reset-bug-on-proxmox/">https://www.nicksherlock.com/2020/11/working-around-the-amd-gpu-reset-bug-on-proxmox/</a>
After installing the vendor reset like describer in the post I could adjust my resolution.</p>
<h3 id="redirect-usb-devices">Redirect USB devices</h3>
<p>As a final step I redirected my mouse and keyboard.
For this I first detected the <code>&lt;vendor-id&gt;:&lt;product-id&gt;</code> of the devices using <code>lsusb</code> on the host machine.
Then I rebound them using:
<code>qm set &lt;VM-ID&gt; -usb0 host=&lt;vendor-id&gt;:&lt;product-id&gt;</code>.</p>

        </div>

                </div>
            <div class="pagination">
                <div class="pagination__buttons"></div>
            </div>
        </div>
        
    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Stefan Dienst</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
